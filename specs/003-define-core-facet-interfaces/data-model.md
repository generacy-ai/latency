# Data Model: Define core facet interfaces

## Core Entities

### Shared Types (common.ts)

```typescript
FacetError extends Error {
  code: string
  cause?: Error
}

PaginatedQuery {
  limit?: number
  offset?: number
}

PaginatedResult<T> {
  items: T[]
  total: number
  hasMore: boolean
}
```

### IssueTracker Domain

```
IssueTracker (interface)
├── createIssue(spec: IssueSpec) → Promise<Issue>
├── getIssue(id: string) → Promise<Issue>
├── updateIssue(id: string, update: IssueUpdate) → Promise<Issue>
├── listIssues(query: IssueQuery) → Promise<PaginatedResult<Issue>>
└── addComment(issueId: string, comment: string) → Promise<Comment>

Issue { id, title, body, state, labels[], assignees[], createdAt, updatedAt }
IssueSpec { title, body?, labels?[], assignees?[] }
IssueUpdate { title?, body?, state?, labels?[], assignees?[] }
IssueQuery extends PaginatedQuery { state?, labels?[], assignee? }
Comment { id, body, author, createdAt }
```

### SourceControl Domain

```
SourceControl (interface)
├── commit(spec: CommitSpec) → Promise<Commit>
├── getBranch() → Promise<string>
├── listBranches() → Promise<Branch[]>
├── createBranch(name: string, from?: string) → Promise<Branch>
├── getDiff(from?: string, to?: string) → Promise<DiffEntry[]>
└── push(remote?: string) → Promise<void>

Commit { id, message, author, date, files[] }
CommitSpec { message, files[] }
Branch { name, current, head }
DiffEntry { path, status, additions, deletions }
```

### DecisionHandler Domain

```
DecisionHandler (interface)
├── requestDecision(spec: DecisionSpec) → Promise<DecisionResult>
└── getDecision(id: string) → Promise<DecisionResult>

DecisionSpec { question, options[], urgency, context? }
DecisionOption { id, label, description? }
DecisionResult { id, question, selectedOption, reason?, decidedAt }
Urgency = 'low' | 'medium' | 'high' | 'critical'
```

### WorkflowEngine Domain

```
WorkflowEngine (interface)
├── execute(spec: WorkflowSpec) → Promise<WorkflowResult>
├── getStatus(workflowId: string) → Promise<WorkflowStatus>
└── cancel(workflowId: string) → Promise<void>

WorkflowSpec { id?, name, steps[] }
WorkflowStep { id, name, handler, input?, dependsOn?[] }
WorkflowResult { id, name, status, steps[], startedAt, completedAt? }
StepResult { stepId, status, output?, error? }
WorkflowStatus = 'pending' | 'running' | 'completed' | 'failed' | 'cancelled'
```

### Logger Domain

```
Logger (interface)
├── debug(message: string, context?: Record<string, unknown>) → void
├── info(message: string, context?: Record<string, unknown>) → void
├── warn(message: string, context?: Record<string, unknown>) → void
└── error(message: string, context?: Record<string, unknown>) → void

LogLevel = 'debug' | 'info' | 'warn' | 'error'
```

### StateStore Domain

```
StateStore (interface)
├── get<T>(key: string) → Promise<T | undefined>
├── set<T>(key: string, value: T) → Promise<void>
├── delete(key: string) → Promise<boolean>
├── has(key: string) → Promise<boolean>
└── keys() → Promise<string[]>
```

### EventBus Domain

```
EventBus (interface)
├── emit(event: string, payload: unknown) → void
├── on(event: string, handler: (payload: unknown) => void) → Unsubscribe
└── off(event: string, handler: (payload: unknown) => void) → void

Unsubscribe = () => void
```

### SecretStore Domain

```
SecretStore (interface)
├── getSecret(key: string) → Promise<string | undefined>
├── setSecret(key: string, value: string) → Promise<void>
├── deleteSecret(key: string) → Promise<boolean>
└── hasSecret(key: string) → Promise<boolean>
```

## Relationships

```
PaginatedQuery ←──extends── IssueQuery
PaginatedResult<T> ←──used by── IssueTracker.listIssues()
FacetError ←──thrown by── all async facet methods on failure
```

All facets are independent — no facet imports from another facet. They share only common types.

## Validation Rules

- All `id` fields are `string` (implementation-specific format)
- All async methods throw `FacetError` on failure
- Logger methods are synchronous — the only exception
- EventBus payloads are `unknown` — type narrowing is the consumer's responsibility
- SecretStore values are always `string` — serialization is the caller's responsibility

---

*Generated by speckit*
