# Research: Define core facet interfaces

## Technology Decisions

### Pure Interfaces vs. Abstract Classes
**Decision**: Use TypeScript `interface` for all facets (except `FacetError` which is a `class`).

**Rationale**:
- Interfaces have zero runtime cost — they're erased during compilation
- Multiple interface implementation (`implements A, B`) is natural in TypeScript
- Abstract classes would force single inheritance chains and add runtime weight
- The architecture explicitly separates Tier 1 (interfaces) from Tier 2 (abstract classes)

**Alternative considered**: Abstract base classes with default methods. Rejected because Tier 2 abstract plugins serve that purpose.

### Error Handling: Throw vs. Result Type
**Decision**: Throw `FacetError` (from clarification #2).

**Rationale**:
- Standard JavaScript/TypeScript pattern — familiar to all developers
- `instanceof` checking allows catching specific error subtypes
- Result types (`Result<T, E>`) add ceremony without clear benefit for this layer
- Implementations can subclass `FacetError` for domain-specific errors

### Pagination: Shared Mixin Types
**Decision**: Shared `PaginatedQuery` / `PaginatedResult<T>` (from clarification #3).

**Rationale**:
- Consistent pagination across all list operations
- Optional — facets without list operations (Logger, StateStore, SecretStore) don't use them
- `PaginatedResult<T>` provides `total` and `hasMore` for UI-friendly pagination
- Composable via intersection types: `IssueQuery & PaginatedQuery`

### EventBus Payload Typing
**Decision**: `unknown` payloads (from clarification #4).

**Rationale**:
- Core EventBus is maximally flexible — any data can be emitted
- Type-safe event maps (`EventMap<{ 'issue.created': Issue }>`) are a Tier 3 concern
- Keeps the core interface simple and uncoupled from specific event schemas
- Consumers cast to known types at subscription sites

### Synchronous Logger
**Decision**: Logger methods are synchronous (return `void`, not `Promise<void>`).

**Rationale**:
- Logging should never block the caller
- Most logging implementations buffer writes internally
- Async logging complicates every call site with unnecessary `await`
- This is the one exception to the "async-first" principle — deliberate and documented

## Implementation Patterns

### JSDoc Convention
Every public export gets:
- A description of what it represents
- For interfaces: what kind of implementations exist (examples)
- For methods: parameter descriptions and return semantics

### Module Suffix Convention
All internal imports use `.js` suffix for ESM compatibility with NodeNext module resolution:
```typescript
export * from './facets/index.js';
```

### Type-Only Exports
All facet files export only types and interfaces (except `common.ts` which exports `FacetError` class). This means the compiled JS files will be minimal — mostly re-exports.

## Key Sources

- [latency-architecture.md](/workspaces/tetrad-development/docs/latency-architecture.md) — Tier 1 core facet definitions
- [latency-integration-plan.md](/workspaces/tetrad-development/docs/latency-integration-plan.md) — Issue 1.2 requirements
- Issue #3 spec — Clarified design decisions

---

*Generated by speckit*
