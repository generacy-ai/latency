# Feature Specification: Health Check Facet

**Branch**: `030-add-health-check-endpoint` | **Date**: 2026-02-09 | **Status**: Draft

## Summary

Add a `HealthCheck` facet to the latency plugin framework that provides service health, uptime, and version information. This facet enables monitoring systems and load balancers to query the status of a latency-powered service via a standardized interface, with a default HTTP plugin implementation.

## User Stories

### US1: Operations Engineer Monitors Service Health

**As an** operations engineer,
**I want** a standardized health check interface for latency-based services,
**So that** I can integrate with monitoring tools and load balancers to detect unhealthy instances.

**Acceptance Criteria**:
- [ ] Health check returns status (healthy/degraded/unhealthy), uptime, and version
- [ ] Response includes individual check results for each registered health contributor
- [ ] Response time is under 100ms for basic checks

### US2: Developer Registers Custom Health Checks

**As a** plugin developer,
**I want** to register custom health check contributors from my plugin,
**So that** my plugin's dependencies (database, external API, etc.) are included in the overall health status.

**Acceptance Criteria**:
- [ ] Plugins can register named health check contributors via PluginContext
- [ ] Each contributor returns its own status independently
- [ ] Overall status is the worst of all contributor statuses

## Functional Requirements

| ID | Requirement | Priority | Notes |
|----|-------------|----------|-------|
| FR-001 | Define `IHealthCheck` facet interface with `getHealth()` method | P1 | Returns `HealthStatus` object |
| FR-002 | `HealthStatus` includes: status enum, uptime, version, timestamp, checks array | P1 | |
| FR-003 | Default implementation aggregates all registered health contributors | P1 | Worst status wins |
| FR-004 | HTTP plugin exposes `GET /health` endpoint returning JSON health status | P2 | Optional plugin |
| FR-005 | Support health check timeout (default 5s) to prevent hanging checks | P2 | |

## Technical Design

### HealthCheck Facet Interface

```typescript
interface IHealthCheck {
  getHealth(): Promise<HealthStatus>;
  registerContributor(name: string, check: HealthContributor): void;
}

interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  uptime: number;        // seconds
  version: string;
  timestamp: string;     // ISO 8601
  checks: HealthCheckResult[];
}

interface HealthCheckResult {
  name: string;
  status: 'healthy' | 'degraded' | 'unhealthy';
  message?: string;
  duration?: number;     // ms
}

type HealthContributor = () => Promise<HealthCheckResult>;
```

### Package Structure

- `packages/latency/src/facets/health-check.ts` — Facet definition
- `packages/latency-plugin-health-check/` — Default implementation plugin
- `packages/latency-plugin-health-check-http/` — Optional HTTP server plugin (express-based)

## Success Criteria

| ID | Metric | Target | Measurement |
|----|--------|--------|-------------|
| SC-001 | Basic health check response time | < 50ms | Unit test timing |
| SC-002 | All existing tests pass | 100% | CI pipeline |
| SC-003 | Type-safe facet integration | No `any` types | TypeScript strict mode |

## Assumptions

- The latency framework's existing facet registration pattern (FacetRegistry, PluginContext) is used
- Version information comes from package.json
- Process uptime is sufficient (no need for persistent uptime tracking)

## Out of Scope

- Authentication/authorization on the health endpoint
- Health check history or trending
- Push-based health notifications (pull-only via facet interface)
- Kubernetes-specific liveness/readiness probe differentiation (single endpoint)

---

*Generated by speckit*
