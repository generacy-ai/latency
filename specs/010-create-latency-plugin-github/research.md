# Research: GitHub Issues Plugin

## Technology Decisions

### @octokit/rest v21

**Choice**: Use `@octokit/rest` as the GitHub API client.

**Rationale**:
- Official GitHub SDK for REST API
- Full TypeScript types for all endpoints
- Built-in authentication, pagination, and rate limit handling
- Actively maintained by GitHub
- Widely used — stable API surface

**Alternatives Considered**:
- **Raw `fetch`**: More control but requires manual auth, pagination, error handling, and type definitions
- **GraphQL (`@octokit/graphql`)**: More flexible queries but spec explicitly scopes to REST API only
- **`@octokit/core`**: Lower-level; would need to manually construct endpoint URLs

### Error Mapping Strategy

**Choice**: Map Octokit errors to `FacetError` with standard codes.

**Codes**:
| HTTP Status | FacetError Code | Description |
|-------------|-----------------|-------------|
| 404 | `NOT_FOUND` | Issue/resource doesn't exist |
| 401, 403 | `AUTH_ERROR` | Token invalid/insufficient permissions |
| 429 | `RATE_LIMIT` | API rate limit exceeded |
| 422 | `VALIDATION` | Invalid request parameters |
| Other | `UNKNOWN` | Unexpected errors |

**Rationale**: FacetError is the ecosystem standard. GitHub-specific details (rate limit reset time, scopes needed) go in the error's `cause` for debugging without leaking GitHub abstractions to consumers.

### Plugin + Interface Pattern

**Choice**: Two separate packages — interface (types only) and plugin (implementation).

**Rationale**:
- Consumers that only need types (e.g., UI components rendering GitHubIssue) don't pull in `@octokit/rest`
- Follows established ecosystem pattern (e.g., `latency` core exports types, plugins import them)
- Interface package has zero runtime dependencies beyond `@generacy-ai/latency`

### Comment-Based PR Linking

**Choice**: `linkPullRequest` adds a comment mentioning the PR number.

**Rationale**:
- GitHub has no dedicated "link PR to issue" REST API endpoint
- Adding a comment like "Linked to #123" creates an automatic bidirectional reference in GitHub's UI
- The Timeline API shows these references natively
- Alternative (using `Fixes #N` in PR body) requires modifying the PR, not the issue

## Implementation Patterns

### ID String Parsing

The `AbstractIssueTrackerPlugin` uses `string` IDs throughout. GitHub Issues use numeric `issue_number`. The plugin must parse string IDs to numbers:

```typescript
private parseIssueNumber(id: string): number {
  const num = parseInt(id, 10);
  if (isNaN(num) || num <= 0) {
    throw new FacetError(`Invalid issue number: ${id}`, 'VALIDATION');
  }
  return num;
}
```

### Octokit Response Mapping

Octokit returns rich response objects. Mappers extract only the fields defined in `GitHubIssue`/`Comment`:

- `data.number` → `GitHubIssue.number`
- `data.id` → `GitHubIssue.id` (as string)
- `data.html_url` → `GitHubIssue.htmlUrl`
- `data.state` → `GitHubIssue.state` (already 'open' | 'closed')
- `data.labels` → `GitHubIssue.labels` (extract name strings)
- `data.assignees` → `GitHubIssue.assignees` (extract login strings)
- `data.pull_request` → detect linked PRs
- `data.milestone` → `GitHubIssue.milestone` (map if present)
- `data.reactions` → `GitHubIssue.reactions` (map counts)

### Pagination Mapping

GitHub's list API uses `per_page` and `page` parameters. Map from `PaginatedQuery`:

```
query.limit → per_page (default 30, max 100)
query.offset → page = Math.floor(offset / limit) + 1
```

The total count comes from the response headers or can be estimated from the result set size.

### Test Mocking Strategy

Mock `@octokit/rest` at the module level:

```typescript
vi.mock('@octokit/rest', () => ({
  Octokit: vi.fn().mockImplementation(() => ({
    issues: {
      get: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
      listForRepo: vi.fn(),
      createComment: vi.fn(),
      addLabels: vi.fn(),
    },
  })),
}));
```

This avoids network calls and gives full control over response shapes.

---

*Generated by speckit*
