# Quickstart: Document planned facets and reconcile dual StateStore

## Overview

This change improves documentation and eliminates a naming collision in the latency core package.

## What Changed

### 1. Facet Documentation

All five planned facet interfaces now have JSDoc `@remarks` tags indicating their adoption status:

- `EventBus` (facets/events.ts)
- `SecretStore` (facets/secrets.ts)
- `StateStore` (facets/state.ts)
- `DecisionHandler` (facets/decision.ts)
- `WorkflowEngine` (facets/workflow.ts)

A new `facets/README.md` provides a centralized maturity matrix.

### 2. StateStore Rename

The sync `StateStore` in `composition/context.ts` is now `PluginStateStore`.

**Before**:
```typescript
import { StateStore } from '@generacy-ai/latency';
// Ambiguous: which StateStore?
```

**After**:
```typescript
import { StateStore, PluginStateStore } from '@generacy-ai/latency';
// StateStore = async facet (for persistent storage)
// PluginStateStore = sync (for plugin-scoped in-memory state)
```

## Usage Examples

### Using the Facet StateStore (Async, Persistent)

```typescript
import type { StateStore } from '@generacy-ai/latency';

class RedisStateStore implements StateStore {
  async get<T>(key: string): Promise<T | undefined> {
    const value = await this.redis.get(key);
    return value ? JSON.parse(value) : undefined;
  }

  async set<T>(key: string, value: T): Promise<void> {
    await this.redis.set(key, JSON.stringify(value));
  }

  async delete(key: string): Promise<boolean> {
    return (await this.redis.del(key)) > 0;
  }

  async has(key: string): Promise<boolean> {
    return (await this.redis.exists(key)) > 0;
  }

  async keys(prefix?: string): Promise<string[]> {
    return this.redis.keys(prefix ? `${prefix}*` : '*');
  }
}
```

### Using PluginStateStore (Sync, In-Memory)

```typescript
import type { PluginContext } from '@generacy-ai/latency';

function activate(ctx: PluginContext): void {
  // PluginStateStore is used via ctx.state
  ctx.state.set('initialized', true);

  const count = ctx.state.get<number>('requestCount') ?? 0;
  ctx.state.set('requestCount', count + 1);
}
```

## Build & Verify

```bash
# Build the package
pnpm build

# Verify no duplicate StateStore definitions
grep -r "interface StateStore" packages/latency/src/
# Should only return facets/state.ts
```

## Troubleshooting

### Import Error: "StateStore is ambiguous"

If you were relying on the implicit override where composition's StateStore shadowed the facet version, update your imports:

```typescript
// Before (potentially ambiguous)
import { StateStore } from '@generacy-ai/latency';

// After (explicit)
import { PluginStateStore } from '@generacy-ai/latency';
```

### Type Error: "PluginContext.state" expects PluginStateStore

If you're implementing a custom PluginContext, update the `state` property type:

```typescript
// Before
readonly state: StateStore;

// After
readonly state: PluginStateStore;
```

---

*Generated by speckit*
